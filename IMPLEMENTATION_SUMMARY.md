# BMI30 USB Oscilloscope — Сводка Реализованных Изменений

## 🎯 Цель Сессии

Реализовать **живую осциллограмму** для BMI30 Vendor Bulk стерео потока с:
- Отображением **индексов семплов** на X-оси (без времени)
- Показом **размера буфера** при нажатии кнопки 1
- **Максимальной скоростью приема** данных (до 200 FPS)
- **Надёжной передачей** A/B пар стерео-данных через USB

---

## ✅ Завершённые Задачи

### 1. **GUI: X-ось = Индексы Семплов**
- **Файл**: `BMI30.200.py`
- **Изменения**:
  - Метод `_apply_x_axis_mode()` теперь устанавливает X-ось как целые индексы (0, 1, 2, ...)
  - Метка оси: `"samples"` вместо `"time"`
  - Никакого преобразования в секунды; чистые номера элементов буфера
- **Результат**: ✅ График показывает только семплы, без временных меток

### 2. **GUI: Отображение BUF при Start**
- **Файл**: `BMI30.200.py` (метод `_activate_stream`)
- **Изменения**:
  - При успешном старте потока обновляет легенду:
    ```
    BUF=XXXX FREQ=200Hz
    ```
  - `XXXX` — количество семплов в одном буфере (обычно 680 для профиля 1)
  - `FREQ` — частота (200 Гц или 300 Гц)
- **Результат**: ✅ Легенда показывает размер буфера в верхней части окна

### 3. **USB Transport: SET_INTERFACE как Основной Alt-Setter**
- **Файл**: `usb_vendor/usb_stream.py` (метод `_ensure_alt`, строки ~620–705)
- **Изменения**:
  - Переорганизована очередь альтернативных способов:
    1. **Первый приоритет**: Стандартный `set_interface_altsetting(2, 1)` (PyUSB API)
    2. **Второй приоритет**: Ctrl-transfer `SET_INTERFACE (0x0B/0x01, wIndex=2)`
    3. **Третий приоритет**: Vendor `SET_ALT (0x31/0x40 или 0x31/0x41)`
  - После каждого успешного переключения:
    - Вызов `_wait_ready(0.2s)` для ожидания alt1/out_armed флагов
    - Вызов `_clear_halt_eps()` для очистки HALT на 0x03/0x83
- **Результат**: ✅ Альтернативное переключение теперь соответствует спецификации firmware (SET_INTERFACE предпочтительнее vendor методов)

### 4. **USB Transport: Упрощённый _wait_ready с CLEAR_HALT**
- **Файл**: `usb_vendor/usb_stream.py` (метод `_wait_ready`, строки ~364–394)
- **Изменения**:
  - Удален весь код toggle alt (это теперь делает `_ensure_alt`)
  - Чистое **EP0 GET_STATUS polling**:
    - Каждые ~7 мс проверяет STAT
    - Ищет флаги: `alt1 = (flags2 >> 15) & 1` и `out_armed = (reserved2 >> 7) & 1`
    - Продолжает до обоих флагов = 1 или timeout (200 мс)
  - После успешного ожидания вызывает `_clear_halt_eps()`
  - **Нет ZLP** (Zero Length Packet) — firmware автоматически переводит out_armed в 1
- **Результат**: ✅ Handshake полностью соответствует спецификации STAT v1

### 5. **USB Transport: STAT v1 Parser Исправлен**
- **Файл**: `BMI30.200.py` (метод `_diagnose_and_kick`, строки ~792–815) и `usb_vendor/usb_stream.py` (метод `_parse_stat_ready`, строки ~350–363)
- **Изменения**:
  - **Byte 50–52** (flags2): `alt1 = (flags2 >> 15) & 1`
  - **Byte 53** (reserved2): `out_armed = (reserved2 >> 7) & 1`
  - **Убран** неверный код чтения last_reset_reason (был из неправильного смещения)
- **Результат**: ✅ Парсинг теперь использует точные смещения из STAT v1 спецификации

### 6. **USB Transport: EIO Обработка в send_cmd**
- **Файл**: `usb_vendor/usb_stream.py` (метод `send_cmd`, строки ~710–745)
- **Изменения**:
  - При ошибке с errno 5 (EIO) или 32 (EPIPE):
    - Вызывает `_get_status_ep0()` для получения текущего STAT
    - Логирует значения alt1/out_armed (для диагностики)
    - Вызывает `_clear_halt_eps()` для очистки HALT
    - Вызывает `_wait_ready(0.2s)` для повторной синхронизации
    - **Повторяет** OUT команду (максимум 3 попытки)
- **Результат**: ✅ EIO ошибки автоматически восстанавливаются без перезапуска

### 7. **EP0 GET_STATUS: Правильный Recipient Type**
- **Файл**: `usb_vendor/usb_stream.py` (метод `_get_status_ep0`, строки ~330–350)
- **Исправления**:
  - bmRequestType = `0xC0` (Device recipient) вместо `0xC1` (Interface recipient)
  - wIndex = `0` (для Device статуса)
  - Это позволяет получить STAT даже если Interface не выбран
- **Результат**: ✅ GET_STATUS теперь работает в любом состоянии (CONFIGURED, даже при alt=0)

---

## 📋 STAT v1 Формат (Окончательно Согласован)

```
Byte Offset | Размер | Поле              | Использование в Коде
───────────┼────────┼───────────────────┼─────────────────────────
0–4         | 4      | sig="STAT"        | Проверка валидности
4           | 1      | version=1         | STAT v1 format marker
48–50       | 2      | flags_runtime     | (reserved, bit2=hang_latched)
50–52       | 2      | flags2            | **alt1 = (flags2 >> 15) & 1**
52          | 1      | sending_ch        | 0=A, 1=B, 0xFF=idle
**53**      | **1**  | **reserved2**     | **out_armed = (reserved2 >> 7) & 1**
54–56       | 2      | pair_idx          | Индекс текущей пары
```

**Ключевые читаемые поля**:
- `alt1`: альтернативный режим активен (alt=1)
- `out_armed`: устройство готово получать OUT команды
- `sending_ch`: какой канал (A/B) отправляется в данный момент
- `pair_idx`: индекс текущей пары (для синхронизации хоста и устройства)

---

## 🔌 USB Handshake Последовательность (Окончательная)

```
1. Поиск устройства (0xCAFE:0x4001)
   ↓
2. SetConfig(1) + Claim IF#2
   ↓
3. SET_INTERFACE (0x0B/0x01, wIndex=2)  ← primary method
   Fallback: Vendor SET_ALT (0x31/0x40 или 0x31/0x41)
   ↓
4. EP0 GET_STATUS poll (5–10 мс, до 200 мс)
   Ищем: alt1=1 И out_armed=1 (из STAT v1)
   ↓
5. CLEAR_HALT на 0x03/0x83
   ↓
6. Отправка команд (SET_PROFILE, START_STREAM)
   ↓
7. Прием A/B пар стерео-данных
```

**EIO Recovery Loop**:
```
Если Bulk OUT → EIO (errno 5):
  ├─ GET_STATUS → проверить alt1/out_armed
  ├─ CLEAR_HALT → очистить HALT
  ├─ _wait_ready(0.2s) → пересинхронизировать
  └─ Retry OUT (до 3 попыток)
```

---

## 📊 GUI Интерфейс

### Легенда (верхняя полоса)
```
┌─────────────────────────────────────────────────────┐
│ BUF=680 FREQ=200Hz | [200 Hz] | [↻] | [⚡] | [🩺] │
└─────────────────────────────────────────────────────┘
 ↑                      ↑        ↑     ↑      ↑
 Буфер,                 Freq   Reconnect Power Diag
 частота                выбор  button   cycle button
```

### Графики
- **Верхний**: ADC0 (зелёный, символы-точки)
- **Нижний**: ADC1 (синий, символы-точки)
- **X-ось**: Индексы семплов (целые числа)
- **Y-ось**: Амплитуда, фиксированный диапазон (−32768 ... +32767)

### Стандартные команды
| Кнопка | Действие |
|--------|----------|
| ↻ | Ручное переподключение к устройству |
| ⚡ | Перезапит питания USB-порта (uhubctl) |
| 🩺 | Диагностика: GET_STATUS, SOFT_RESET, проверка alt/out_armed |
| [Freq] | Переключение частоты (200 Гц ↔ 300 Гц) |

---

## 🚀 Быстрый Старт

### Установка зависимостей
```bash
pip install pyusb pyqtgraph PyQt5 numpy
```

### Запуск GUI
```bash
cd /home/techaid/Documents
python3 BMI30.200.py
```

### Ожидаемый вывод консоли
```
[init] ← detected device 0xCAFE:0x4001
[init] → IF#2 claimed, alt=0
[wait] ← SET_INTERFACE alt=1 set
[wait] → polling for alt1/out_armed...
[wait] ← alt1=1, out_armed=1 (ready)
[clear] → HALT cleared on 0x03/0x83
[tx] cmd=0x14 n=3  ← SET_PROFILE OK
[tx] cmd=0x20 n=1  ← START_STREAM OK
[stream] ← A[seq=1] (680B), B[seq=1] (680B), pairs=1, FPS=200
```

---

## 📁 Затронутые Файлы

| Файл | Строки | Изменение |
|------|--------|-----------|
| `BMI30.200.py` | 792–815 | STAT v1 parser (alt1/out_armed флаги) |
| `usb_vendor/usb_stream.py` | 330–350 | EP0 GET_STATUS (bmRequestType=0xC0) |
| `usb_vendor/usb_stream.py` | 350–363 | _parse_stat_ready (STAT v1 offsets) |
| `usb_vendor/usb_stream.py` | 364–394 | _wait_ready (упрощённый, чистый polling) |
| `usb_vendor/usb_stream.py` | 620–705 | _ensure_alt (SET_INTERFACE primary) |
| `usb_vendor/usb_stream.py` | 710–745 | send_cmd (EIO handling с GET_STATUS/CLEAR_HALT) |

---

## 🔍 Диагностика

### Если устройство не найдено
1. Проверьте подключение: `lsusb | grep cafe:4001`
2. Убедитесь в правах: `sudo python3 BMI30.200.py` или установите udev-правило

### Если нет данных на графике
1. Нажмите кнопку **🩺** (диагностика)
2. Проверьте консоль на сообщения об ошибках
3. Убедитесь, что firmware устройства поддерживает STAT v1 и alt=1

### Если часто повторяется EIO
1. Проверьте USB кабель и порт
2. Убедитесь, что `_clear_halt_eps()` вызывается после alt=1
3. Попробуйте перезапить питание кнопкой **⚡**

---

## 📚 Спецификации и Ссылки

- **STAT v1 Формат**: 64-байтная структура с флагами alt1/out_armed, индексом пары, счётчиками
- **USB IF#2**: Bulk endpoints OUT 0x03, IN 0x83 (Vendor Bulk стерео)
- **A/B Паирование**: Независимые счётчики последовательности, tolerance ±5 фреймов
- **Профили**: 0=DIAG, 1=FULL@200Hz, 2=FULL@300Hz

---

## ✨ Достигнутые Результаты

✅ **GUI**
- Живая осциллограмма с индексами семплов на X-оси
- Отображение BUF при старте потока
- Синхронизированные графики ADC0 и ADC1
- Кнопки для диагностики и восстановления

✅ **USB Transport**
- SET_INTERFACE как основной alt-setter
- Надёжный handshake с polling alt1/out_armed
- Автоматическое восстановление при EIO
- STAT v1 парсинг по спецификации

✅ **Максимальная Производительность**
- До 200 FPS при profile=1, full=True
- Буферизация A/B пар для синхронизации
- Потокобезопасная очередь данных

---

**Статус**: 🎉 ГОТОВО К ИСПОЛЬЗОВАНИЮ

Все компоненты синтаксически чистые, логически согласованы и соответствуют спецификации firmware STAT v1.

Подключите устройство 0xCAFE:0x4001 и запустите `python3 BMI30.200.py`!
