# USB VENDOR ПРОТОКОЛ (версия 1.0)

Документ фиксирует формат кадров, команды управления и инварианты хоста/прошивки. Цель — исключить регрессии и «забывание» деталей при дальнейших изменениях.

## 1. Идентификация устройства
VID: 0xCAFE  
PID: 0x4001  
Composite: CDC + Vendor (интерфейс vendor обычно №2).  
Bulk endpoints (alt0):
- OUT: 0x03 (host → device, команды)
- IN : 0x83 (device → host, поток и статус / тестовый кадр)

## 2. Формат потокового кадра
Каждый кадр = 32‑байтовый заголовок `VendorHdr` + payload (сырые сэмплы) + (опц.) CRC16.

```
Offset Size  Field            Type      Описание
0      2     magic            u16       0xA55A (LE)
2      1     version          u8        Текущая версия структуры (1)
3      1     flags            u8        Биты, см. ниже
4      4     seq              u32       Номер логической последовательности (кадровая пара)
8      4     timestamp        u32       Временная метка (мс или device ticks*)
12     2     total_samples    u16       Кол-во сэмплов в payload (для данного ADC кадра)
14     2     zone_count       u16       Зарезервировано (0)
16     4     zone1_offset     u32       Зарезервировано (0)
20     4     zone1_length     u32       Зарезервировано (0)
24     4     reserved         u32       (0)
28     2     reserved2        u16       (0)
30     2     crc16            u16       CRC16-CCITT-FALSE заголовок+payload (при флаге CRC)
```
Endian: Little‑endian для всех многобайтовых полей.

Payload: массив `total_samples` значений по 2 байта (LE). (Т.е. размер payload = `2 * total_samples`).  
Флаг CRC (bit2) определяет присутствие и валидацию crc16. Если бит не установлен — поле crc16 может быть 0 (игнорируется).

### 2.1 Флаги `flags`
| Бит | Маска | Значение                    |
|-----|-------|----------------------------|
| 0   | 0x01  | Кадр ADC0                  |
| 1   | 0x02  | Кадр ADC1                  |
| 2   | 0x04  | CRC включён                |
| 7   | 0x80  | Тестовый кадровый маркер   |

Комбинации: рабочие кадры используют ровно один из {0x01,0x02} (+ возможно 0x04). Тестовый кадр: 0x81 (ADC0 + TEST).  
Флаги 0x01 и 0x02 одного и того же `seq` образуют стерео‑пару. 

### 2.2 Последовательность и пары
`seq` инкрементируется после успешной отправки двух кадров (ADC0 и ADC1) для данной последовательности.  
Инвариант: для любого `seq` должно быть не более по одному кадру с флагом 0x01 и по одному с 0x02. Дубликаты запрещены.  
Хост проверяет: монотонность seq без дыр; приём пары -> счётчик стерео‑пар.

### 2.3 Фиксация размера (auto‑lock)
Алгоритм прошивки:
1. `cur_samples_per_frame` = 0 при старте.
2. Первый полный DMA кадр (или отдельный механизм) фиксирует значение `cur_samples_per_frame` и вычисляет `cur_expected_frame_size = 32 + 2*cur_samples_per_frame`.
3. Все следующие кадры должны иметь ровно `total_samples == cur_samples_per_frame`. Иначе — игнорируются (`dbg_partial_frame_abort++`).

Допустимые рабочие размеры на сегодня: 912 / 944 / 976 (примерные варианты).  
Тестовый кадр (8 сэмплов) НЕ фиксирует рабочий размер; хост игнорирует его при установке `exp_frame_size`.

## 3. Команды управления (bulk OUT на EP 0x03)
Каждая команда: первый байт = код, далее опциональный payload (не более 63 байт). Ответ (если предусмотрен) приходит как отдельный bulk IN пакет (может быть статусным коротким кадром или стандартным кадром, в зависимости от реализации).

| Код  | Имя             | Назначение | Payload OUT | Ответ IN |
|------|-----------------|------------|-------------|----------|
|0x14  | CMD_SET_PROFILE | Выбор профиля обработки/фильтра | 1 байт profile | (опц.) статус*
|0x13  | CMD_SET_FULL_MODE| 0=ROI, 1=FULL режим захвата    | 1 байт flag    | (опц.) статус*
|0x15  | CMD_SET_ROI_US  | Задание ROI в мкс (формат TBD)  | 4 байта (u32)  | (опц.) статус*
|0x20  | CMD_START_STREAM| Запуск потока: отправить тестовый кадр + начать фиксацию размера | none | поток
|0x21  | CMD_STOP_STREAM | Остановка: прекращение потока, сброс внутренних флагов | none | статусная структура
|0x30  | CMD_GET_STATUS  | (Расширенный) запрос статуса     | none | статусная структура

`*` Статус после SET_* может быть отложен или не возвращаться — зависит от реализации. Гарантированно возвращается после STOP и GET_STATUS.

## 4. Статусная структура (предложенный/текущий вид)
Передаётся в виде отдельного короткого bulk IN пакета (<=64 байт). Предлагаемое поле `magic='STAT'` (4 ASCII) для идентификации.

```
struct __attribute__((packed)) VendorStatus {
    char     sig[4];            // 'STAT'
    uint8_t  version;           // 1
    uint8_t  reserved0;
    uint16_t cur_samples;       // зафиксированный cur_samples_per_frame (0 если ещё нет)
    uint16_t frame_bytes;       // 32 + 2*cur_samples (0 если нефикс.)
    uint16_t test_frames;       // сколько тестовых кадров отправлено
    uint32_t produced_seq;      // текущий seq (созданных пар)
    uint32_t sent0;             // отправлено ADC0 кадров
    uint32_t sent1;             // отправлено ADC1 кадров
    uint32_t dbg_tx_cplt;       // завершений (USBD_VND_TxCplt)
    uint32_t dbg_partial_frame_abort; // отфильтровано частичных
    uint32_t dbg_size_mismatch; // несовпадений размеров (если считаются)
    uint32_t dma_done0;         // DMA full complete ADC0
    uint32_t dma_done1;         // DMA full complete ADC1
    uint32_t frame_wr_seq;      // внутренняя позиция записи кадра/буфера
    uint16_t flags_runtime;     // runtime флаги state machine
    uint16_t reserved1;
};
```

Хост может парсить по сигнатуре и выводить метрики даже до старта основного потока.

## 5. Тестовый кадр
Отправляется сразу после `CMD_START_STREAM`.  
Флаги: 0x81 (бит7 TEST + бит0 ADC0).  
`total_samples=8`, фиксированные/диагностические данные.  
Не влияет на фиксацию рабочего размера кадра.

## 6. CRC16 (опционально)
Алгоритм: CRC16-CCITT-FALSE (poly=0x1021, init=0xFFFF, без рефлексии).  
Порядок вычисления: сначала 30 байт заголовка (без поля crc16), затем payload.  
При несоответствии — хост увеличивает `crc_bad` и может сбрасывать поток/запрашивать STOP.

## 7. Инварианты, которые проверяет хост
1. Все рабочие кадры (не TEST) имеют одинаковый `total_samples = exp_samples`.
2. `exp_frame_size` фиксируется по первому рабочему кадру и не меняется.
3. Для каждого `seq` присутствуют либо оба кадра (0x01 и 0x02), либо (во время запуска) временно один; дубликаты запрещены.
4. Нет коротких IN transfers кроме тестового кадра или статусных пакетов <=64B.
5. `crc_bad == 0` при включенном флаге CRC.
6. Без пропусков последовательности (`seq_gaps == 0`) и без откатов.

## 8. Отладочные счётчики прошивки (минимум)
- `produced_seq` — сколько пар сформировано (инкремент после отправки обеих ADC).
- `sent0/sent1` — фактическое кол-во отправленных кадров по каждому ADC.
- `dbg_tx_cplt` — число завершений передачи на уровне USB.
- `dbg_partial_frame_abort` — игнорированных кадров из-за несоответствия размера до фиксации.
- `dbg_size_mismatch` — кадров с неверной длиной (если включено).
- `dma_done0/dma_done1` — завершения DMA.
- `frame_wr_seq` — индекс производственного кольца.

## 9. Типичные проблемы и их сигнатуры
| Симптом (хост)                        | Возможная причина прошивки                      |
|--------------------------------------|-------------------------------------------------|
| Только тестовый кадр, далее тишина   | Не стартует DMA / не фиксируется размер         |
| `magic_bad` растёт                   | Перезапись буфера до полной готовности / мусор  |
| `transfer_len_min < transfer_len_max`| Смешаны разные `total_samples`                   |
| `gaps` > 0 при `dup_seq` растущем    | Повторная отправка завершённых seq              |
| Нет статусного ответа                | Статус шлётся на другой endpoint или не формируется |

## 10. Roadmap (расширения)
- Динамическая смена размера кадра через новую команду (например 0x31) с подтверждением.
- Включение CRC по отдельной команде (0x32) + бит флага.
- Введение зон (zone_count >0) для сегментации payload.
- Метка точного времени (timestamp 64‑бит) в версии 2 заголовка.

## 11. Требования к обратной совместимости
Изменение структуры `VendorHdr` требует:
1. Инкрементировать `version`.
2. Не изменять первые 12 байт (magic, version, flags, seq) — хост полагается на них.
3. Добавлять новые поля только в хвост либо через `zone` блоки.

## 12. Минимальный алгоритм хоста (C)
1. Открыть устройство, определить ep_in/ep_out.
2. Поставить очередь IN transfers.
3. Отправить SET_* команды.
4. Отправить START_STREAM.
5. Игнорировать тестовый кадр (flags & 0x80).
6. Первый рабочий кадр фиксирует `exp_frame_size`/`exp_samples`.
7. Собираем пары по (seq, flags).
8. По завершении — STOP_STREAM → прочитать статус.

## 13. Диагностический чеклист при регрессии
1. Есть ли тестовый кадр? Если нет — проблема в пути USB передачи.
2. Растут ли dma_doneX? Если нет — ADC/DMA не стартует.
3. Фиксировался ли cur_samples_per_frame? Если 0 — нет первого полного кадра.
4. Есть ли расхождение sent0 != sent1? Если да — один ADC не даёт буфер.
5. Есть дубликаты seq? Если да — повторная отправка того же буфера.

---
Обновления документа фиксировать с версионным блоком CHANGELOG ниже.

### CHANGELOG
v1.0 — Изначальная фиксация спецификации (заголовок v1, тестовый кадр, команды 0x13/14/15/20/21/30, статусная структура v1).
