Описание протокола обмена между Raspberry PI5 и STM32H723
Роли:

Raspberry Pi (Мастер): Инициирует все обмены. Ожидает перехода из 0 в 1 по выводу GPIO22, по которому формируется прерывание, 
означающее что у STM32 есть данные для передачи. Также управляет линией Chip Select GPIO 8 (CS, у нас это PB12 для STM32). 
Запрашивает данные, когда ему это удобно и STM32 готов к передаче.
STM32 (Ведомый): Постоянно собирает данные в кольцевой буфер из 8 буферов по 1375 16 битных слов (2 байта) с помощью DMA.
Как только данные Готовы для передачи, выставляет "1" флаг готовности передачи на выводе PB8, который подключен к GPIO22 RPI. 
Отвечает на запросы мастера, отдавая данные по SPI, также с помощью DMA.
Процесс обмена:

Шаг 1: Запрос данных (Command Phase).

RPI проверяет значение вывода gpio22. "1"-stm32 готов к передаче данных; "0"-STM32 не готов к передаче данных. 
 
RPi использует линию CS (PB12) в как линия SPI0 CS0.
RPi отправляет по SPI короткий командный пакет (6 байт). В это время STM32 принимает эту команду
в специальный буфер spi_command_buffer с помощью DMA для SPI_RX.
Команда содержит: [ID буфера (0-7), Стартовый адрес в буфере, Длина данных].
Как только началась передача команды на STM32, STM32 выставляет "0" по линии PD8.
RPi после передачи командного пакета ждет готовности передачи данных от STM32. Флаг по линии GPIO22 получает "1".

Шаг 2: Обработка команды на STM32 (Interrupt).

Поднятие линии CS (PB12) в '1' вызывает на STM32 внешнее прерывание (EXTI), Означающее что по SPI пришли данные.
В обработчике прерывания EXTI:
STM32 анализирует полученные данные/команду из spi_command_buffer.
Настраивает DMA для SPI_TX на передачу запрошенного блока данных (указывает на нужный буфер, адрес и длину) и 
выставляет на вывод PD8 "1". 
Процессор освобождается и продолжает заниматься своими делами (ФАПЧ, LCD и т.д.).

Шаг 3: Получение данных (Data Phase).

RPi, получив по gpio22 "1", получает прерывание и если он отправлял команду требующую получения данных получает по SPI0 данные.
RPi начинает "читать" по SPI, отправляя байты для ЦАП соответсвующего канала (Для начала фиктивные, 0xFF), чтобы генерировать тактовые импульсы.
STM32, у которого уже настроен DMA на передачу в режиме Ведомый, автоматически выставляет на линию MISO запрошенные данные из ADC буфера.
RPi принимает данные, с указанным количеством.
RPi поднимает CS в '1', завершая транзакцию.
Эта схема полностью асинхронна, не блокирует процессор STM32 и устойчива к задержкам Linux.

Итого:

// Формат команды: [ADC_ID(1), BUF_IDX(1), ST_ADDR(2), LEN_DATA(2)] - пример
// byte 0: ID команды (0x01=ADC1, 0x02=ADC2 или другие устройства в диапазоне до 0x7F) (0x00 и 0xFF защитные или фиктивные);
// byte 1: Индекс буфера (0-7) только для ID команды 0x01 и 0x02;
// byte 2-3: Стартовый адрес данных (uint16_t) только для ID команды 0x01 и 0x02;
// byte 4-5: Длина данных (uint16_t) только для ID команды 0x01 и 0x02;




Реализация на STM32
Нам понадобится настроить SPI2 в режиме Slave с DMA для RX и TX, а также прерывание EXTI на ножке PB12.

1. Настройка в CubeMX
SPI2:
Mode: Full-Duplex Slave.
DMA Settings: Добавляем DMA для SPI2_RX и SPI2_TX. Устанавливаем Mode для обоих в Normal (не Circular).
GPIO PB12:
Настраиваем как GPIO_EXTI12.
В System Core -> GPIO устанавливаем для PB12 GPIO mode -> External Interrupt Mode with Rising edge trigger (срабатывание по переднему фронту).
NVIC:
Проверяем, что прерывания для SPI2 и EXTI line[15:10] включены.